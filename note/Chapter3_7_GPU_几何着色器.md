## Chapter 3.7 The Geometry Shader

参考

[OpenGL Learn Cn](https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/09%20Geometry%20Shader/)


>* The geometry shader can turn primitives into other primitives, something the tessellation
stage cannot do. For example, a triangle mesh could be transformed to a
wireframe view by having each triangle create line edges. Alternately, the lines could
be replaced by quadrilaterals facing the viewer, so making a wireframe rendering with
thicker edges [1492]. The geometry shader was added to the hardware-accelerated
graphics pipeline with the release of DirectX 10, in late 2006. It is located after the
tessellation shader in the pipeline, and its use is optional. While a required part of
Shader Model 4.0, it is not used in earlier shader models. OpenGL 3.2 and OpenGL
ES 3.2 support this type of shader as well.
---
几何着色器能够将基元转化为其他的基元，这是曲面细分阶段做不到的。

例如，可以将三角形网格转化为线框视图，因为每个三角形都能产生相应的线段。

或者，这些线段能产生面向观察者的四边形，这样线框渲染可以变成厚的边缘的渲染。

在2006年，DX10的发布中，几何着色器已经添加到了硬件加速的管线中。

它在 曲面细分着色器之后，并且它是可选择的。

它是 SM 4.0 的一部分，在早期的渲染模型中不适用。

OpenGL 3.2 和 OpenGL ES 3.2  同样支持。

>* The input to the geometry shader is a single object and its associated vertices. The
object typically consists of triangles in a strip, a line segment, or simply a point. Extended
primitives can be defined and processed by the geometry shader. In particular,
three additional vertices outside of a triangle can be passed in, and the two adjacent
vertices on a polyline can be used. See Figure 3.12. With DirectX 11 and Shader
Model 5.0, you can pass in more elaborate patches, with up to 32 control points. That
said, the tessellation stage is more efficient for patch generation [175].
---
几何着色器的输入是一个物体以及他相关联的顶点。

这里说的物体，一般是，一组三角形，一条线，或者简单的一个点。

我们能通过 gs 来拓展和定义额外的基元。

特别是，可以在三角形外传入3个额外的点，在线段外传入2个额外的点，来拓展。如图3.12

在Dx11，SM 5.0， 你可以传入更加精细的 patch，控制着32个点。

这意味着，曲面细分着色器对 patch 的生成更加高效了。

![3.12](pic/3/3.12.png)

几何着色器的输入是：点，线段，三角形

最右边2种基元，包含了邻近的点。

>* The geometry shader processes this primitive and outputs zero or more vertices,
which are treated as points, polylines, or strips of triangles. Note that no output at
all can be generated by the geometry shader. In this way, a mesh can be selectively
modified by editing vertices, adding new primitives, and removing others.
---
几何着色器处理基元，并输出0或者许多的顶点（可以当场点，线，或者三角形）

请注意，几何着色器也可以什么也不生成。

通过这种方式，一个网格可以选择性的，修改顶点，增加基元，或者删除。

>* The geometry shader is designed for modifying incoming data or making a limited
number of copies. For example, one use is to generate six transformed copies of data
to simultaneously render the six faces of a cube map; see Section 10.4.3. It can also be
used to efficiently create cascaded shadow maps for high-quality shadow generation.
Other algorithms that take advantage of the geometry shader include creating variablesized
particles from point data, extruding fins along silhouettes for fur rendering, and
finding object edges for shadow algorithms. See Figure 3.13 for more examples. These
and other uses are discussed throughout the rest of the book.
---
几何着色器被设计为，对输入数据修改，或者对复制的数量进行限制（看不懂这个功能）

比如，一个用处就是生成6个 变换后的数据，来同时生成并渲染正方体的6个面 （10.4.3）。

它也能用来为高质量的阴影创建次级阴影贴图。

也有很多其他的算法，非常容易在gs上实现，比如由点数据创建变量例子，拓展边缘沿着轮廓的毛发渲染，查找阴影算法的物体边缘。

在3.13中可以看到例子。

这些和一些其他的算法会在本书的其余部分讨论。

![3.13](pic/3/3.13.png)
>* Some uses of the geometry shader (GS). On the left, metaball isosurface tessellation is
performed on the fly using the GS. In the middle, fractal subdivision of line segments is done using
the GS and stream out, and billboards are generated by the GS for display of the lightning. On
the right, cloth simulation is performed by using the vertex and geometry shader with stream out.
(Images from NVIDIA SDK 10 [1300] samples, courtesy of NVIDIA Corporation.)
---
这里是 gs 的一些用途.

最左边是材质细分就是用 gs 算的。

中间是线段的细分和流输出，生成广告版和闪电的特效。

右边是布料模拟，通过vs和gs的流输出。

>* DirectX 11 added the ability for the geometry shader to use instancing, where the
geometry shader can be run a set number of times on any given primitive [530, 1971]. In
OpenGL 4.0 this is specified with an invocation count. The geometry shader can also
output up to four streams. One stream can be sent on down the rendering pipeline for
further processing. All these streams can optionally be sent to stream output render
targets.
---
DX 11 增加了为 gs 添加使用实例化的功能，这能够让 gs 对给定的任意基元执行一定的次数。

在 OpenGL 4.0 这被称为 调用记数。

gs 最多输出到4个流。

其中一个流能够被送到管线中进行下一步的处理。

所有的流都能被选择性的输出到指定的渲染目标上。

>* The geometry shader is guaranteed to output results from primitives in the same
order that they are input. This affects performance, because if several shader cores
run in parallel, results must be saved and ordered. This and other factors work against
the geometry shader being used to replicate or create a large amount of geometry in
a single call [175, 530].
---
几何着色器能保证输出结果的基元会跟他们输入的顺序一样。

这个会影响性能，因为数个着色器核心并行运行，但结果必须被保存和记数。

这些原因不利于 gs 在单次调用中 处理复制的或者创建一大堆几何体。

>* After a draw call is issued, there are only three places in the pipeline where work can
be created on the GPU: rasterization, the tessellation stage, and the geometry shader.
Of these, the geometry shader’s behavior is the least predictable when considering
resources and memory needed, since it is fully programmable. In practice the geometry
shader usually sees little use, as it does not map well to the GPU’s strengths. On
some mobile devices it is implemented in software, so its use is actively discouraged
there [69].
---
在 dc 调用后，管线中只有3个地方可以进行GPU上的创建，光栅化，曲面细分和几何着色器。

而几何着色器的行为是最不可预测的，因为它是完成可编程的，需要不同的资源和内存。

事实上，gs很少使用，因为它没有充分发挥GPU的优势。

有些手机硬件会在软件上完成gs，因此它不被推荐使用。

### 3.7.1 Stream Output

>* The standard use of the GPU’s pipeline is to send data through the vertex shader,
then rasterize the resulting triangles and process these in the pixel shader. It used to
be that the data always passed through the pipeline and intermediate results could
not be accessed. The idea of stream output was introduced in Shader Model 4.0.
After vertices are processed by the vertex shader (and, optionally, the tessellation and
geometry shaders), these can be output in a stream, i.e., an ordered array, in addition
to being sent on to the rasterization stage. Rasterization could, in fact, be turned off
entirely and the pipeline then used purely as a non-graphical stream processor. Data
processed in this way can be sent back through the pipeline, thus allowing iterative
processing. This type of operation can be useful for simulating flowing water or other
particle effects, as discussed in Section 13.8. It could also be used to skin a model and
then have these vertices available for reuse (Section 4.4).
---
标准的管线流程，数据是通过 vs，光栅化三角形，并传给 ps。

过去这个管线的流程中的中间结果是不能获取的。

但SM 4.0 提出了流输出的理念。

在 vs 处理顶点之后（可选的 曲面细分 和 gs），它除了送到光栅化阶段之外，还能输出到一个流中，比如一个有序的数组。

事实上，我们可以将光栅化关闭，然后管道就成了一个非图像的流处理器。

数据可以通过这种方式，通过流发送回来，因此能够用这个来进行迭代处理。

这种操作对模仿水流或者粒子效果非常有用 （13.8）

它通用也可以用作对模型蒙皮，让顶点进行重复使用（4.4） （应用不太懂，后续再看看）

>* Stream output returns data only in the form of floating point numbers, so it can
have a noticeable memory cost. Stream output works on primitives, not directly on
vertices. If meshes are sent down the pipeline, each triangle generates its own set
of three output vertices. Any vertex sharing in the original mesh is lost. For this
reason a more typical use is to send just the vertices through the pipeline as a point
set primitive. In OpenGL the stream output stage is called transform feedback, since
the focus of much of its use is transforming vertices and returning them for further
processing. Primitives are guaranteed to be sent to the stream output target in the
order that they were input, meaning the vertex order will be maintained [530].
---
流输出返回的数据都是浮点数，因此它的内存消耗很高。

流输出使用于基元，而不是顶点。

如果网格送入管线，每个三角形都会生成它自己的3个点集。

任何网格中的顶点共享内容将会丢失。

因此一个更典型的用法就是将管道的基元就是一个点。

在OpenGl中，流疏忽从阶段被称为变换反馈，因为它专注于转换顶点并返回他们做进一步的处理。

流输出的基元会按照输入的顺序输出，这意味着能够保持顶点的顺序。


