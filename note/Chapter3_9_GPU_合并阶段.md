## Chapter 3.9 The Merging Stage

参考

>* As discussed in Section 2.5.2, the merging stage is where the depths and colors of the
individual fragments (generated in the pixel shader) are combined with the framebuffer.
DirectX calls this stage the output merger; OpenGL refers to it as per-sample
operations. On most traditional pipeline diagrams (including our own), this stage is
where stencil-buffer and z-buffer operations occur. If the fragment is visible, another
operation that takes place in this stage is color blending. For opaque surfaces there
is no real blending involved, as the fragment’s color simply replaces the previously
stored color. Actual blending of the fragment and stored color is commonly used for
transparency and compositing operations (Section 5.5).
---
就像在2.5.2中描述的一样，合并阶段是将单个片元的深度和颜色，进行合并，并写入缓冲中。

DX叫做 output merger, OpenGL 称之为 per-sample。

在大多数传统的管道图上，这个阶段会发生 模板缓冲 和 z缓冲的操作。

如果该片元是可见的，那么会发生另外一个操作，颜色混合。

对于不透明的表面来说，没有涉及到真正的混合，因为片元的颜色只是做了简单的替换。

事实上，我们用片元的颜色，和存储的颜色，做透明度上的合成操作。

>* Imagine that a fragment generated by rasterization is run through the pixel shader
and then is found to be hidden by some previously rendered fragment when the zbuffer
is applied. All the processing done in the pixel shader was then unnecessary.
To avoid this waste, many GPUs perform some merge testing before the pixel shader
is executed [530]. The fragment’s z-depth (and whatever else is in use, such as the
stencil buffer or scissoring) is used for testing visibility. The fragment is culled if
hidden. This functionality is called early-z [1220, 1542]. The pixel shader has the
ability to change the z-depth of the fragment or to discard the fragment entirely.
If either type of operation is found to exist in a pixel shader program, early-z then
generally cannot be used and is turned off, usually making the pipeline less efficient.
DirectX 11 and OpenGL 4.2 allow the pixel shader to force early-z testing to be on,
though with a number of limitations [530]. See Section 23.7 for more about early-z
and other z-buffer optimizations. Using early-z effectively can have a large effect on
performance, which is discussed in detail in Section 18.4.5.
---
详细一下，一个由光栅化和ps生成的片元，在使用 z缓冲是，发现它被藏在了其他片元的前面。（就不能渲染了，辛苦一番，结果通不过z测试）

那这些在ps的操作都是没有必要的了。

为了避免这种浪费，许多GPU允许先做 merge 的一些测试，然后再跑 ps。

片元的 z深度（或者是其他的用途的内容，能够确定是否显示的，比如模板测试 和 裁剪），被用于测试，是否应该可见。

这个片元会被裁剪掉，如果被判断是隐藏的话。

这个功能叫做 early-z.

ps 有改变片元z深度或者丢弃片元的能力。

如果发现像素着色器程序中存在任何类型的操作，那么 early-z 通常不能使用并且会关闭，这会导致 管线的效率 降低。

DX11 和 OpenGL 4.2 允许  ps 强制打开 early-z , 虽然有许多限制。

23.7 节有更多的 early-z 操作，和其他 z缓冲 有关的操作。

通常使用 early-z 能够大大的增强性能，在18.4.5中会讨论他的细节。

>* The merging stage occupies the middle ground between fixed-function stages, such
as triangle setup, and the fully programmable shader stages. Although it is not programmable,
its operation is highly configurable. Color blending in particular can be
set up to perform a large number of different operations. The most common are combinations
of multiplication, addition, and subtraction involving the color and alpha
values, but other operations are possible, such as minimum and maximum, as well as
bitwise logic operations. DirectX 10 added the capability to blend two colors from
the pixel shader with the framebuffer color. This capability is called dual source-color
blending and cannot be used in conjunction with multiple render targets. MRT does
otherwise support blending, and DirectX 10.1 introduced the capability to perform
different blend operations on each separate buffer.
---
merge 阶段，在固定管线的阶段中，处于一个中间的位置，例子就像是 完全不变的三角形设置，和完全编程的 shader阶段。

尽管 它 是不可编程的，但它的操作是高度可配置的。

特别是颜色混合，我们可以设置去执行大量的不同的操作。

最通常的操作就是，颜色和alpha 的乘法，加法和减法，当然，其他的操作也有，比如取最大值，最小值，以及位运算。

DX10 增加了 用2种来自 ps 的颜色，和缓冲颜色混合的功能。

这个功能被称为，双-源-颜色混合，但不能和 MRT 一起使用。

MRT 是用其他的混合方式，而且 DX 10.1 推出了 对每个不同的缓冲，使用不同的blend操作的功能。

>* As mentioned at the end of the previous section, DirectX 11.3 provided a way to
make blending programmable through ROVs, though at a price in performance. ROVs
and the merging stage both guarantee draw order, a.k.a. output invariance. Regardless
of the order in which pixel shader results are generated, it is an API requirement that
results are sorted and sent to the merging stage in the order in which they are input,
object by object and triangle by triangle
---
之前说过，DX 11.3 支持通过 ROV 来实现混合编程，尽管要付出高昂的性能代价。

ROV 和 合并阶段 都能保证绘制的顺序，即，输出不变性。（这里的输出不变性是什么，是指一个片元被多次ps渲染，最终的结果不变？）

不管 ps 的结果的生成顺序，它是在 API 的要求，结果（PS的渲染）会被存储，并传递到 merge 阶段中，（传入merge时）按照他们输入的顺序，逐个物体中再逐个三角形